<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.3.2">
<title data-rh="true">권우석 | 권우석</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://egg528.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://egg528.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://egg528.github.io/"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" property="og:title" content="권우석 | 권우석"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/img/egg.png"><link data-rh="true" rel="canonical" href="https://egg528.github.io/"><link data-rh="true" rel="alternate" href="https://egg528.github.io/" hreflang="ko"><link data-rh="true" rel="alternate" href="https://egg528.github.io/" hreflang="x-default"><script data-rh="true">function insertBanner(){var n=document.createElement("div");n.id="__docusaurus-base-url-issue-banner-container";n.innerHTML='\n<div id="__docusaurus-base-url-issue-banner" style="border: thick solid red; background-color: rgb(255, 230, 179); margin: 20px; padding: 20px; font-size: 20px;">\n   <p style="font-weight: bold; font-size: 30px;">Your Docusaurus site did not load properly.</p>\n   <p>A very common reason is a wrong site <a href="https://docusaurus.io/docs/docusaurus.config.js/#baseUrl" style="font-weight: bold;">baseUrl configuration</a>.</p>\n   <p>Current configured baseUrl = <span style="font-weight: bold; color: red;">/</span>  (default value)</p>\n   <p>We suggest trying baseUrl = <span id="__docusaurus-base-url-issue-banner-suggestion-container" style="font-weight: bold; color: green;"></span></p>\n</div>\n',document.body.prepend(n);var e=document.getElementById("__docusaurus-base-url-issue-banner-suggestion-container"),s=window.location.pathname,o="/"===s.substr(-1)?s:s+"/";e.innerHTML=o}document.addEventListener("DOMContentLoaded",(function(){void 0===window.docusaurus&&insertBanner()}))</script><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"Blog","@id":"https://egg528.github.io/","mainEntityOfPage":"https://egg528.github.io/","headline":"blog","description":"Blog","blogPost":[{"@type":"BlogPosting","@id":"https://egg528.github.io/singleton-pattern","mainEntityOfPage":"https://egg528.github.io/singleton-pattern","url":"https://egg528.github.io/singleton-pattern","headline":"디자인 패턴 - Singleton Pattern","name":"디자인 패턴 - Singleton Pattern","description":"이 글은 Singleton Pattern에 대해 설명합니다. Singleton Pattern은 클래스의 인스턴스를 하나만 생성하고, 해당 인스턴스에 전역적으로 접근할 수 있도록 보장하는 디자인 패턴입니다. 이 글에서는 synchronized 키워드, static 필드, 그리고 DCL (Double-Checked Locking) 방식의 세 가지 Singleton 구현 방법을 비교합니다. 또한, volatile 키워드가 적용된 변수와 그렇지 않은 변수의 조회 성능을 비교하는 코드를 통해 성능 차이를 분석합니다. Singleton Pattern의 개념과 구현 방법을 이해하는 데 중점을 둡니다.","datePublished":"2024-05-26T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/factory-pattern","mainEntityOfPage":"https://egg528.github.io/factory-pattern","url":"https://egg528.github.io/factory-pattern","headline":"디자인 패턴 - Factory Pattern","name":"디자인 패턴 - Factory Pattern","description":"이 글은 Factory Pattern의 정의와 그 다양한 방식들에 대해 설명합니다. 기본적으로 Factory Pattern은 클래스 인스턴스를 생성하는 책임을 전담하는 인터페이스를 두어, 클라이언트가 구체적인 구현체에 의존하지 않도록 하는 디자인 패턴입니다. 이를 통해 코드의 변경 없이 다양한 구현체를 사용할 수 있게 됩니다.","datePublished":"2024-05-25T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/spring-batch-job-launcher","mainEntityOfPage":"https://egg528.github.io/spring-batch-job-launcher","url":"https://egg528.github.io/spring-batch-job-launcher","headline":"Spring Batch 파헤치기 - JobLauncher","name":"Spring Batch 파헤치기 - JobLauncher","description":"이 글은 Spring Batch의 JobLauncher와 그 구현체들에 대해 설명합니다. JobLauncher는 Job과 JobParameters를 받아 Job을 실행하는 역할을 하며, 이를 통해 클라이언트가 구체적인 구현체에 의존하지 않고 Batch 작업을 실행할 수 있습니다. 또한, Spring Boot의 AutoConfiguration을 통해 TaskExecutorJobLauncher가 자동으로 Bean으로 등록되는 과정을 살펴봅니다. JobLauncher의 동작 원리와 SimpleJobLauncher의 구현 세부사항을 통해 Batch의 핵심적인 동작 방식을 이해할 수 있습니다.","datePublished":"2024-05-23T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/decorator-pattern","mainEntityOfPage":"https://egg528.github.io/decorator-pattern","url":"https://egg528.github.io/decorator-pattern","headline":"디자인 패턴 - Decorator Pattern","name":"디자인 패턴 - Decorator Pattern","description":"이 글은 디자인 패턴 중 하나인 Decorator Pattern에 대해 설명합니다. Decorator Pattern은 객체에 추가적인 기능을 동적으로 더할 수 있는 패턴으로, 기존 코드의 변경 없이 다양한 기능을 추가할 수 있습니다. 이를 통해 코드의 유연성과 확장성을 높이며, 디자인 원칙을 준수할 수 있습니다. Decorator Pattern의 구조와 예시를 통해 그 동작 원리와 장점을 이해할 수 있습니다.","datePublished":"2024-05-22T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/observer-pattern","mainEntityOfPage":"https://egg528.github.io/observer-pattern","url":"https://egg528.github.io/observer-pattern","headline":"디자인 패턴 - Observer Pattern","name":"디자인 패턴 - Observer Pattern","description":"이 글은 Observer Pattern에 대해 설명합니다. Observer Pattern은 한 객체의 상태 변화가 다른 객체들에게 자동으로 통보되는 구조로, 주로 Subject와 Observer로 구성됩니다. 글에서는 Push 방식과 Pull 방식의 구현 방법을 코드 예제로 설명하고, Spring Framework의 ApplicationEventPublisher와 ApplicationListener를 실제 예시로 다룹니다.","datePublished":"2024-05-22T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/annotation-config-application-context2","mainEntityOfPage":"https://egg528.github.io/annotation-config-application-context2","url":"https://egg528.github.io/annotation-config-application-context2","headline":"Annotation 기반의 ApplicationContext Bean 등록 과정 파헤치기 (2)","name":"Annotation 기반의 ApplicationContext Bean 등록 과정 파헤치기 (2)","description":"이 글은 Annotation 기반의 ApplicationContext에서 @Component와 @Bean 애노테이션을 통해 클래스가 어떻게 Bean으로 등록되는지 설명합니다. Spring Boot의 SpringApplication.run() 메서드에서 시작하여 refreshContext() 메서드 내부에서 Bean 등록 과정이 이루어집니다. Component Scan을 통해 BeanDefinition을 등록하고, BeanPostProcessor를 설정한 후 Singleton Bean을 초기화하는 과정을 코드와 함께 상세히 다룹니다.","datePublished":"2024-05-21T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/strategy-pattern","mainEntityOfPage":"https://egg528.github.io/strategy-pattern","url":"https://egg528.github.io/strategy-pattern","headline":"디자인 패턴 - Strategy Pattern","name":"디자인 패턴 - Strategy Pattern","description":"이 글은 디자인 패턴 중 하나인 Strategy Pattern에 대해 설명합니다. Strategy Pattern은 알고리즘을 캡슐화하여 독립적으로 변경할 수 있게 하는 패턴으로, 클라이언트와 알고리즘을 분리하여 유연성을 높입니다. 이를 통해 알고리즘의 확장과 변형이 용이하고, 코드 재사용성을 높이며, 객체 간의 결합도를 낮추어 유지보수를 쉽게 합니다. 코드 예시와 함께 Spring Framework의 DispatcherServlet과 HandlerMapping을 통한 실제 적용 사례를 다룹니다.","datePublished":"2024-05-19T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/annotation-config-application-context","mainEntityOfPage":"https://egg528.github.io/annotation-config-application-context","url":"https://egg528.github.io/annotation-config-application-context","headline":"Annotation 기반의 ApplicationContext Bean 등록 과정 파헤치기 (1)","name":"Annotation 기반의 ApplicationContext Bean 등록 과정 파헤치기 (1)","description":"이 글은 Spring IoC, DI, IoC Container, 그리고 ApplicationContext에 대해 설명합니다. Spring IoC는 Inversion of Control의 약어로, 객체의 제어권을 외부로 넘기는 개념입니다. DI는 의존성 주입을 의미하며, IoC를 구현하는 구체적인 방법입니다. IoC Container는 ApplicationContext로, Bean을 초기화, 조립, 구성하는 역할을 합니다. 특히 Annotation 기반의 ApplicationContext를 중심으로, Spring Boot 애플리케이션에서 Bean이 어떻게 등록되고 초기화되는지 과정을 코드와 함께 살펴봅니다.","datePublished":"2024-05-18T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/jdbc-datasource-hikaricp","mainEntityOfPage":"https://egg528.github.io/jdbc-datasource-hikaricp","url":"https://egg528.github.io/jdbc-datasource-hikaricp","headline":"JDBC, DataSource 그리고 HikariCP","name":"JDBC, DataSource 그리고 HikariCP","description":"이 글은 Java 애플리케이션과 데이터베이스 간의 연결을 관리하는 JDBC (Java Database Connectivity)와 이를 효율적으로 관리하기 위한 데이터 소스(DataSource) 및 HikariCP에 대해 설명합니다. JDBC는 표준 API로, DriverManager를 통해 DB와의 연결을 관리하지만, 성능 문제가 있습니다. 이를 해결하기 위해 데이터 소스(DataSource)가 등장했으며, 특히 HikariCP는 고성능 JDBC 커넥션 풀로 성능 최적화를 통해 빠르고 효율적인 DB 연결을 제공합니다. HikariCP의 장점과 동작 방식을 코드 예제와 함께 다룹니다.","datePublished":"2024-05-12T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]},{"@type":"BlogPosting","@id":"https://egg528.github.io/the-cafe-on-the-edge-of-the-world","mainEntityOfPage":"https://egg528.github.io/the-cafe-on-the-edge-of-the-world","url":"https://egg528.github.io/the-cafe-on-the-edge-of-the-world","headline":"세상 끝의 카페","name":"세상 끝의 카페","description":"이 글은 책 \"세상 끝의 카페\"의 독후감입니다. 주인공 존이 여행 중 우연히 방문한 카페에서 3가지 질문을 통해 삶의 의미를 찾아가는 이야기를 담고 있습니다. 책은 주인공이 카페 직원과 손님들의 이야기를 통해 '당신은 왜 여기 있습니까?', '죽음이 두렵습니까?', '충만한 삶을 살고 있습니까?'라는 질문에 대한 답을 찾아가며 자신의 삶을 돌아보는 과정을 그립니다. 독자는 이 질문을 통해 자신의 삶을 성찰하고 현재 원하는 것을 명확히 하며 충만한 삶을 살아가는 방법을 모색할 수 있습니다.","datePublished":"2023-12-04T00:00:00.000Z","author":{"@type":"Person","name":"권우석","description":"Server Developer","url":"https://github.com/egg528","image":"https://avatars.githubusercontent.com/u/62459196?v=4"},"keywords":[]}]}</script><link rel="alternate" type="application/rss+xml" href="/rss.xml" title="권우석 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="권우석 Atom Feed">






<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&amp;display=swap"><link rel="stylesheet" href="/assets/css/styles.74aead1c.css">
<script src="/assets/js/runtime~main.990dcf01.js" defer="defer"></script>
<script src="/assets/js/main.f7a725fc.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="Main" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Blog</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">PARA Note</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/project/intro">Project</a></li><li><a class="dropdown__link" href="/area/intro">Area</a></li><li><a class="dropdown__link" href="/resource/intro">Resource</a></li><li><a class="dropdown__link" href="/archive/intro">Archive</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://egg528.github.io/pdf/resume.pdf" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Resume<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/singleton-pattern">디자인 패턴 - Singleton Pattern</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/factory-pattern">디자인 패턴 - Factory Pattern</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/spring-batch-job-launcher">Spring Batch 파헤치기 - JobLauncher</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/decorator-pattern">디자인 패턴 - Decorator Pattern</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/observer-pattern">디자인 패턴 - Observer Pattern</a></li></ul></nav></aside><main class="col col--7"><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/singleton-pattern">디자인 패턴 - Singleton Pattern</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-26T00:00:00.000Z">2024년 5월 26일</time> · <!-- -->약 6분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 Singleton Pattern에 대해 설명합니다. Singleton Pattern은 클래스의 인스턴스를 하나만 생성하고, 해당 인스턴스에 전역적으로 접근할 수 있도록 보장하는 디자인 패턴입니다. 이 글에서는 synchronized 키워드, static 필드, 그리고 DCL (Double-Checked Locking) 방식의 세 가지 Singleton 구현 방법을 비교합니다. 또한, volatile 키워드가 적용된 변수와 그렇지 않은 변수의 조회 성능을 비교하는 코드를 통해 성능 차이를 분석합니다. Singleton Pattern의 개념과 구현 방법을 이해하는 데 중점을 둡니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/design-pattern">design pattern</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/singleton-pattern">singleton pattern</a></li></ul></div><div class="col text--right col--3"><a aria-label="디자인 패턴 - Singleton Pattern 에 대해 더 읽어보기" href="/singleton-pattern"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/factory-pattern">디자인 패턴 - Factory Pattern</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-25T00:00:00.000Z">2024년 5월 25일</time> · <!-- -->약 13분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 Factory Pattern의 정의와 그 다양한 방식들에 대해 설명합니다. 기본적으로 Factory Pattern은 클래스 인스턴스를 생성하는 책임을 전담하는 인터페이스를 두어, 클라이언트가 구체적인 구현체에 의존하지 않도록 하는 디자인 패턴입니다. 이를 통해 코드의 변경 없이 다양한 구현체를 사용할 수 있게 됩니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/design-pattern">design pattern</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/factory-pattern">factory pattern</a></li></ul></div><div class="col text--right col--3"><a aria-label="디자인 패턴 - Factory Pattern 에 대해 더 읽어보기" href="/factory-pattern"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/spring-batch-job-launcher">Spring Batch 파헤치기 - JobLauncher</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-23T00:00:00.000Z">2024년 5월 23일</time> · <!-- -->약 7분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 Spring Batch의 JobLauncher와 그 구현체들에 대해 설명합니다. JobLauncher는 Job과 JobParameters를 받아 Job을 실행하는 역할을 하며, 이를 통해 클라이언트가 구체적인 구현체에 의존하지 않고 Batch 작업을 실행할 수 있습니다. 또한, Spring Boot의 AutoConfiguration을 통해 TaskExecutorJobLauncher가 자동으로 Bean으로 등록되는 과정을 살펴봅니다. JobLauncher의 동작 원리와 SimpleJobLauncher의 구현 세부사항을 통해 Batch의 핵심적인 동작 방식을 이해할 수 있습니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/design-pattern">design pattern</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/observer-pattern">observer pattern</a></li></ul></div><div class="col text--right col--3"><a aria-label="Spring Batch 파헤치기 - JobLauncher 에 대해 더 읽어보기" href="/spring-batch-job-launcher"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/decorator-pattern">디자인 패턴 - Decorator Pattern</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-22T00:00:00.000Z">2024년 5월 22일</time> · <!-- -->약 10분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 디자인 패턴 중 하나인 Decorator Pattern에 대해 설명합니다. Decorator Pattern은 객체에 추가적인 기능을 동적으로 더할 수 있는 패턴으로, 기존 코드의 변경 없이 다양한 기능을 추가할 수 있습니다. 이를 통해 코드의 유연성과 확장성을 높이며, 디자인 원칙을 준수할 수 있습니다. Decorator Pattern의 구조와 예시를 통해 그 동작 원리와 장점을 이해할 수 있습니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/design-pattern">design pattern</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/decorator-pattern">decorator pattern</a></li></ul></div><div class="col text--right col--3"><a aria-label="디자인 패턴 - Decorator Pattern 에 대해 더 읽어보기" href="/decorator-pattern"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/observer-pattern">디자인 패턴 - Observer Pattern</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-22T00:00:00.000Z">2024년 5월 22일</time> · <!-- -->약 12분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 Observer Pattern에 대해 설명합니다. Observer Pattern은 한 객체의 상태 변화가 다른 객체들에게 자동으로 통보되는 구조로, 주로 Subject와 Observer로 구성됩니다. 글에서는 Push 방식과 Pull 방식의 구현 방법을 코드 예제로 설명하고, Spring Framework의 ApplicationEventPublisher와 ApplicationListener를 실제 예시로 다룹니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/design-pattern">design pattern</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/observer-pattern">observer pattern</a></li></ul></div><div class="col text--right col--3"><a aria-label="디자인 패턴 - Observer Pattern 에 대해 더 읽어보기" href="/observer-pattern"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/annotation-config-application-context2">Annotation 기반의 ApplicationContext Bean 등록 과정 파헤치기 (2)</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-21T00:00:00.000Z">2024년 5월 21일</time> · <!-- -->약 9분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 Annotation 기반의 ApplicationContext에서 @Component와 @Bean 애노테이션을 통해 클래스가 어떻게 Bean으로 등록되는지 설명합니다. Spring Boot의 SpringApplication.run() 메서드에서 시작하여 refreshContext() 메서드 내부에서 Bean 등록 과정이 이루어집니다. Component Scan을 통해 BeanDefinition을 등록하고, BeanPostProcessor를 설정한 후 Singleton Bean을 초기화하는 과정을 코드와 함께 상세히 다룹니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/spring">spring</a></li></ul></div><div class="col text--right col--3"><a aria-label="Annotation 기반의 ApplicationContext Bean 등록 과정 파헤치기 (2) 에 대해 더 읽어보기" href="/annotation-config-application-context2"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/strategy-pattern">디자인 패턴 - Strategy Pattern</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-19T00:00:00.000Z">2024년 5월 19일</time> · <!-- -->약 9분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 디자인 패턴 중 하나인 Strategy Pattern에 대해 설명합니다. Strategy Pattern은 알고리즘을 캡슐화하여 독립적으로 변경할 수 있게 하는 패턴으로, 클라이언트와 알고리즘을 분리하여 유연성을 높입니다. 이를 통해 알고리즘의 확장과 변형이 용이하고, 코드 재사용성을 높이며, 객체 간의 결합도를 낮추어 유지보수를 쉽게 합니다. 코드 예시와 함께 Spring Framework의 DispatcherServlet과 HandlerMapping을 통한 실제 적용 사례를 다룹니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/design-pattern">design pattern</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/strategy-pattern">strategy pattern</a></li></ul></div><div class="col text--right col--3"><a aria-label="디자인 패턴 - Strategy Pattern 에 대해 더 읽어보기" href="/strategy-pattern"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/annotation-config-application-context">Annotation 기반의 ApplicationContext Bean 등록 과정 파헤치기 (1)</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-18T00:00:00.000Z">2024년 5월 18일</time> · <!-- -->약 9분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 Spring IoC, DI, IoC Container, 그리고 ApplicationContext에 대해 설명합니다. Spring IoC는 Inversion of Control의 약어로, 객체의 제어권을 외부로 넘기는 개념입니다. DI는 의존성 주입을 의미하며, IoC를 구현하는 구체적인 방법입니다. IoC Container는 ApplicationContext로, Bean을 초기화, 조립, 구성하는 역할을 합니다. 특히 Annotation 기반의 ApplicationContext를 중심으로, Spring Boot 애플리케이션에서 Bean이 어떻게 등록되고 초기화되는지 과정을 코드와 함께 살펴봅니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/spring">spring</a></li></ul></div><div class="col text--right col--3"><a aria-label="Annotation 기반의 ApplicationContext Bean 등록 과정 파헤치기 (1) 에 대해 더 읽어보기" href="/annotation-config-application-context"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/jdbc-datasource-hikaricp">JDBC, DataSource 그리고 HikariCP</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2024-05-12T00:00:00.000Z">2024년 5월 12일</time> · <!-- -->약 10분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 Java 애플리케이션과 데이터베이스 간의 연결을 관리하는 JDBC (Java Database Connectivity)와 이를 효율적으로 관리하기 위한 데이터 소스(DataSource) 및 HikariCP에 대해 설명합니다. JDBC는 표준 API로, DriverManager를 통해 DB와의 연결을 관리하지만, 성능 문제가 있습니다. 이를 해결하기 위해 데이터 소스(DataSource)가 등장했으며, 특히 HikariCP는 고성능 JDBC 커넥션 풀로 성능 최적화를 통해 빠르고 효율적인 DB 연결을 제공합니다. HikariCP의 장점과 동작 방식을 코드 예제와 함께 다룹니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/java">java</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/db">db</a></li></ul></div><div class="col text--right col--3"><a aria-label="JDBC, DataSource 그리고 HikariCP 에 대해 더 읽어보기" href="/jdbc-datasource-hikaricp"><b>자세히 보기</b></a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/the-cafe-on-the-edge-of-the-world">세상 끝의 카페</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-12-04T00:00:00.000Z">2023년 12월 4일</time> · <!-- -->약 12분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/62459196?v=4" alt="권우석"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/egg528" target="_blank" rel="noopener noreferrer"><span>권우석</span></a></div><small class="avatar__subtitle">Server Developer</small></div></div></div></div></header><div class="markdown"><p><strong>✅<!-- --> ChatGPT 요약</strong><br>
<!-- -->이 글은 책 &quot;세상 끝의 카페&quot;의 독후감입니다. 주인공 존이 여행 중 우연히 방문한 카페에서 3가지 질문을 통해 삶의 의미를 찾아가는 이야기를 담고 있습니다. 책은 주인공이 카페 직원과 손님들의 이야기를 통해 &#x27;당신은 왜 여기 있습니까?&#x27;, &#x27;죽음이 두렵습니까?&#x27;, &#x27;충만한 삶을 살고 있습니까?&#x27;라는 질문에 대한 답을 찾아가며 자신의 삶을 돌아보는 과정을 그립니다. 독자는 이 질문을 통해 자신의 삶을 성찰하고 현재 원하는 것을 명확히 하며 충만한 삶을 살아가는 방법을 모색할 수 있습니다.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/book">book</a></li></ul></div><div class="col text--right col--3"><a aria-label="세상 끝의 카페 에 대해 더 읽어보기" href="/the-cafe-on-the-edge-of-the-world"><b>자세히 보기</b></a></div></footer></article><nav class="pagination-nav" aria-label="블로그 게시물 목록 탐색"></nav></main></div></div></div></div>
</body>
</html>